From 2bfcae8b1dfd25995889a8395fcef8a78efe4fc3 Mon Sep 17 00:00:00 2001
From: Jeremy Whiting <jeremy.whiting@collabora.com>
Date: Tue, 16 Sep 2025 14:08:32 -0600
Subject: [PATCH] Use libarchive to decompress database files if needed.

If a database file isn't found by other 5 means but a file with .tar.zst
extension is found decompress it to a temp path in /var/tmp/umr and return
a FILE* to the decompressed file.
Also adds a COMPRESS_DATABASE_FILES cmake option which if set
compresses each database file with gzip after installing. Default is
off.
Decompresses all files in database archive into temp path UMR_DB_TEMP_DIR
which defaults to /var/tmp/umr but can be changed at build time.
Use a database.sha256 file to update extracted files if they change.
Generate a database.sha256 when compressing database.tar.zst.
Install database.sha256 next to database.tar.zst if we are compressing.
When decompressing read and compare database.sha256 to see if we need
to decompress again.
If sha256 files differ, decompress the new database.tar.zst file.
---
 CMakeLists.txt          |   6 ++
 src/app/CMakeLists.txt  |  25 +++++-
 src/lib/database/open.c | 182 +++++++++++++++++++++++++++++++++++++++-
 3 files changed, 211 insertions(+), 2 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 37e5d74..952bd11 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -31,52 +31,57 @@ set(CPACK_GENERATOR "RPM;DEB" CACHE STRING "Package binary using these generator
 set(CPACK_PACKAGING_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}" CACHE STRING "Default packaging prefix." )
 mark_as_advanced(CPACK_GENERATOR)
 
 set(CPACK_DEBIAN_PACKAGE_DEPENDS "libncurses6, libpciaccess-dev, libllvm11, zlib1g-dev, libsdl2-dev, libgbm-dev, libglx-dev, libglew-dev")
 
 set(CPACK_RPM_PACKAGE_AUTOREQ 0)
 set(CPACK_RPM_PACKAGE_AUTOPROV 0)
 set(CPACK_RPM_PACKAGE_REQUIRES "ncurses-libs, libpciaccess, llvm11-libs, zlib, SDL2-devel, libgbm-devel, nanomsg-devel")
 
 include(CPack)
 
 set(CMAKE_CXX_STANDARD 11 CACHE STRING "The C++ standard to use")
 set(CMAKE_CXX_STANDARD_REQUIRED ON)
 
 set(RELEASE_VERSION \"${VERSION_STRING}\")
+set(UMR_DB_TEMP_DIR "/var/tmp/umr" CACHE STRING "Temp path where database should be extracted to. Default is /var/tmp/umr")
+add_compile_definitions(UMR_DB_TEMP_DIR="${UMR_DB_TEMP_DIR}")
 add_definitions(-DUMR_BUILD_VER=${RELEASE_VERSION})
 add_definitions(-DUMR_BUILD_REV=\"${VERSION_REV}\")
 add_definitions(-DUMR_BUILD_BRANCH=\"${VERSION_BRANCH}\")
 add_definitions(-DUMR_DB_DIR=\"${CMAKE_INSTALL_FULL_DATADIR}/umr/database/\")
 add_definitions(-DUMR_SOURCE_DIR=\"${CMAKE_SOURCE_DIR}\")
 
 set(CMAKE_THREAD_PREFER_PTHREAD TRUE)
 find_package(Threads REQUIRED)
 
 find_package(Curses REQUIRED)
 include_directories(${CURSES_INCLUDE_DIRS})
 
 find_package(PCIAccess REQUIRED)
 include_directories(${PCIACCESS_INCLUDE_DIR})
 
+find_library(LIBARCHIVE_LIB archive)
+
 option(BUILD_SHARED_LIBS "Build shared libraries" OFF)
 option(UMR_NO_DRM "Disable libdrm functions to read memory stats (disables server and GUI)" OFF)
 option(UMR_NO_LLVM "Disable LLVM shader disasm functions, suggested for LLVM < 7" OFF)
 option(UMR_STATIC_LLVM "Force using static LLVM libraries instead of preferring dynamic" OFF)
 option(UMR_NEED_RT "Link against RT library, needed for older glibc versions" OFF)
 option(UMR_NO_GUI "Disable umr --gui option" OFF)
 option(UMR_NO_SERVER "Disable umr --server option" ${UMR_NO_GUI})
+option(COMPRESS_DATABASE_FILES "Compress the database files to save disk space" OFF)
 # TODO: can server exist without GUI? assume not
 
 # NOT UMR_NO_GUI is confusing. create a hidden option instead. ON by default
 # https://cmake.org/cmake/help/latest/module/CMakeDependentOption.html
 include(CMakeDependentOption)
 cmake_dependent_option(UMR_GUI "Enable umr --gui option" ON "NOT UMR_NO_GUI" OFF)
 cmake_dependent_option(UMR_SERVER "Enable umr --server option" ON "NOT UMR_NO_SERVER" OFF)
 
 
 if(UMR_NO_DRM)
   set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DUMR_NO_DRM")
   set(UMR_GUI OFF)
   set(UMR_SERVER OFF)
 else()
   find_package(PkgConfig REQUIRED)
@@ -159,25 +164,26 @@ endif()
 
 
 if(UMR_NEED_RT)
 set(RT_LIBS "-lrt")
 else()
 set(RT_LIBS "")
 endif()
 
 set(REQUIRED_EXTERNAL_LIBS
   ${CURSES_LIBRARIES}
   ${PCIACCESS_LIBRARIES}
   Threads::Threads
   ${LLVM_LIBS}
   ${RT_LIBS}
   ${REQUIRED_EXTERNAL_LIBS_GUI}
+  ${LIBARCHIVE_LIB}
 )
 
 # Global setting: build everything position independent
 set(CMAKE_POSITION_INDEPENDENT_CODE ON)
 
 # CFLAGS += -Wall -W -O2 -g3 -Isrc/ -DPIC -fPIC
 set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -W -g3 -pedantic -Werror=format-security -Wunused-result")
 
 add_subdirectory(src)
 add_subdirectory(doc)
diff --git a/src/app/CMakeLists.txt b/src/app/CMakeLists.txt
index 8b7f05e..4505171 100644
--- a/src/app/CMakeLists.txt
+++ b/src/app/CMakeLists.txt
@@ -71,16 +71,39 @@ if(UMR_GUI)
 	    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
 	)
 	install(FILES umrgui DESTINATION ${CMAKE_INSTALL_BINDIR})
 endif()
 
 find_package(bash-completion QUIET)
 if(BASH_COMPLETION_FOUND AND CMAKE_INSTALL_DATAROOTDIR)
 	set(BASH_COMPLETION_COMPLETIONSDIR "${CMAKE_INSTALL_DATAROOTDIR}/bash-completion/completions")
 	set(BASH_COMPLETION_COMPLETIONSDIR "${CMAKE_INSTALL_DATAROOTDIR}/bash-completion/completions" CACHE PATH "Directory bash-completion is installed to")
 	message(STATUS "Bash-completion moved to: ${BASH_COMPLETION_COMPLETIONSDIR}")
 endif()
 if(NOT BASH_COMPLETION_FOUND)
 	set(BASH_COMPLETION_COMPLETIONSDIR "/usr/share/bash-completion/completions")
 endif()
 install(FILES ../../scripts/umr-completion.bash DESTINATION ${BASH_COMPLETION_COMPLETIONSDIR} RENAME umr)
-install(DIRECTORY ../../database/ DESTINATION ${CMAKE_INSTALL_DATADIR}/umr/database/)
+
+if (NOT COMPRESS_DATABASE_FILES)
+  install(DIRECTORY ${PROJECT_SOURCE_DIR}/database/ DESTINATION ${CMAKE_INSTALL_DATADIR}/umr/database/)
+else()
+  message("Comprsessing ${PROJECT_SOURCE_DIR}/database/*")
+  add_custom_command(
+    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/database.tar.zst
+    COMMAND tar --zstd -cf ${CMAKE_CURRENT_BINARY_DIR}/database.tar.zst *
+    DEPENDS ${PROJECT_SOURCE_DIR}/database
+    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}/database
+    COMMENT "Compressing database files..."
+  )
+  add_custom_command(
+    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/database.sha256
+    COMMAND sha256sum ${CMAKE_CURRENT_BINARY_DIR}/database.tar.zst | cut -d ' ' -f1 > ${CMAKE_CURRENT_BINARY_DIR}/database.sha256
+    DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/database.tar.zst
+    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}/database
+    COMMENT "Calculating compressed database sha256sum..."
+  )
+  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/database.tar.zst DESTINATION ${CMAKE_INSTALL_DATADIR}/umr/database/)
+  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/database.sha256 DESTINATION ${CMAKE_INSTALL_DATADIR}/umr/database/)
+
+  add_custom_target(compress_db_files ALL DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/database.tar.zst ${CMAKE_CURRENT_BINARY_DIR}/database.sha256)
+endif()
diff --git a/src/lib/database/open.c b/src/lib/database/open.c
index 90e7abe..32150d9 100644
--- a/src/lib/database/open.c
+++ b/src/lib/database/open.c
@@ -12,61 +12,241 @@
  * all copies or substantial portions of the Software.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  * OTHER DEALINGS IN THE SOFTWARE.
  *
  * Authors: Tom St Denis <tom.stdenis@amd.com>
  */
 
 #include "umr.h"
 
+#include <archive.h>
+#include <archive_entry.h>
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+// Use 16k chunks for decompression
+#define CHUNK 16384
+#define COMPRESSED_DB_FILENAME "database.tar.zst"
+#define HASH_FILENAME "database.sha256"
+
+/**
+ * @brief Create the database temp dir if it doesn't exist.
+ * 
+ * @return 1 if path exists, 0 if unable to create it.
+ */
+int ensureTempDir()
+{
+	mode_t mode = 0755; // Read, write, execute for owner, read execute for others
+
+	if (mkdir(UMR_DB_TEMP_DIR, mode) == 0) {
+		return 1;
+	} else {
+		if (errno == EEXIST) {
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+/** 
+ * @brief Decompress database.tar.zst to get the given file in UMR_DB_TEMP_DIR
+ *
+ * @param archivepath The path that contains database.tar.zst to extract from
+ * @param filename    The name of the database file to extract
+ * @param binary      Flag indicating whether to open the file in binary mode (`1` for binary, `0` for text).
+ * @return File pointer if able to extract, NULL if unable.
+ */
+FILE *umr_database_extract(char *archivepath, char *filename, int binary)
+{
+	char p[512];
+	FILE *f;
+	const char* mode = binary ? "rb" : "r";
+
+	// First see if the database has changed since we extracted it.
+	sprintf(p, "%s/%s", archivepath, HASH_FILENAME);
+	FILE *hashf = fopen(p, "r");
+	char* new_hash = NULL;
+	if (hashf) {
+		char line[128];
+		if (fgets(line, sizeof(line), hashf)) {
+			line[strcspn(line, "\r\n")] = 0; // Strip newline
+			new_hash = strdup(line);
+		}
+		fclose(hashf);
+	}	
+
+	sprintf(p, "%s/%s", UMR_DB_TEMP_DIR, HASH_FILENAME);
+	FILE *hashf2 = fopen(p, "r");
+	if (hashf2 && new_hash) {
+		char line[128];
+		if (fgets(line, sizeof(line), hashf2)) {
+			line[strcspn(line, "\r\n")] = 0; // Strip newline
+			if (strcmp(line, new_hash) == 0) {
+				// Database is the same, so no need to extract again.
+				free(new_hash);
+				fclose(hashf2);
+				sprintf(p, "%s/%s", UMR_DB_TEMP_DIR, filename);
+				f = fopen(p, mode);
+				if (f) {
+					return f;
+				}
+			}
+		}
+	}
+
+	// Either extracted hash doesn't exist or it is different.
+	
+	// Otherwise open the archive
+	// If we can't create the temp path, bail early.
+	if (ensureTempDir() == 0) {
+		return NULL;
+	}
+
+	char *c = getcwd(0, 0);
+	chdir(UMR_DB_TEMP_DIR);
+
+	sprintf(p, "%s%s", archivepath, COMPRESSED_DB_FILENAME);
+	struct archive* ar;
+	struct archive* ext;
+	struct archive_entry *entry;
+	int r;
+
+	ar = archive_read_new();
+	archive_read_support_format_tar(ar);
+	archive_read_support_filter_zstd(ar);
+
+	if ((r = archive_read_open_filename(ar, p, 10240))) {
+		archive_read_free(ar);
+		chdir(c);
+		free(c);
+		return NULL;
+	}
+
+	ext = archive_write_disk_new();
+	archive_write_disk_set_options(ext, ARCHIVE_EXTRACT_TIME | ARCHIVE_EXTRACT_PERM | ARCHIVE_EXTRACT_ACL | ARCHIVE_EXTRACT_FFLAGS);
+	archive_write_disk_set_standard_lookup(ext);
+
+	while (archive_read_next_header(ar, &entry) == ARCHIVE_OK) {
+		r = archive_write_header(ext, entry);
+			if (r == ARCHIVE_OK) {
+			const void *buff;
+			size_t size;
+			la_int64_t offset;
+
+			while ((r = archive_read_data_block(ar, &buff, &size, &offset)) == ARCHIVE_OK) {
+				archive_write_data_block(ext, buff, size, offset);
+			}
+
+			archive_write_finish_entry(ext);
+		} else {
+			archive_read_close(ar);
+			archive_read_free(ar);
+			archive_write_close(ext);
+			archive_write_free(ext);
+			chdir(c);
+			free(c);
+			return NULL;
+		}
+	}
+
+	archive_read_close(ar);
+	archive_read_free(ar);
+	archive_write_close(ext);
+	archive_write_free(ext);
+
+	// Write database.sha256 into the temp dir so we know when we need to extract again later.
+	sprintf(p, "%s/%s", UMR_DB_TEMP_DIR, HASH_FILENAME);
+	hashf = fopen(p, "w");
+	if (hashf) {
+		fprintf(hashf, "%s\n", new_hash);
+		fclose(hashf);
+	}
+	
+	sprintf(p, "%s/%s", UMR_DB_TEMP_DIR, filename);
+	f = fopen(p, mode);
+	chdir(c);
+	free(c);
+	return f;
+}
+
 /**
 	umr_database_open -- try to open a file from various paths
 **/
 
 FILE *umr_database_open(char *path, char *filename, int binary)
 {
 	FILE *f;
 	char p[512];
 	const char* mode = binary ? "rb" : "r";
+	struct stat buffer;
 
 	// 1. try to open it directly
 	f = fopen(filename, mode);
 	if (f)
 		return f;
 
 	// 2. if there is a path option used try that
 	if (path && strlen(path)) {
 		char *s = (path[strlen(path)-1] == '/') ? "" : "/";
 		sprintf(p, "%s%s%s", path, s, filename);
 		f = fopen(p, mode);
 		if (f)
 			return f;
 	}
 
 	// 3. try using an environment path
 	path = getenv("UMR_DATABASE_PATH");
 	if (path) {
 		char *s = (path[strlen(path)-1] == '/') ? "" : "/";
 		sprintf(p, "%s%s%s", path, s, filename);
 		f = fopen(p, mode);
 		if (f)
 			return f;
+
+		sprintf(p, "%s%s%s", path, s, COMPRESSED_DB_FILENAME);
+		if (stat(p, &buffer) == 0) {
+			f = umr_database_extract(path, filename, binary);
+			if (f)
+				return f;
+		}
 	}
 
 	// 4. try using UMR_DB_DIR define
 #ifdef UMR_DB_DIR
 	sprintf(p, "%s%s", UMR_DB_DIR, filename);
 	f = fopen(p, mode);
 	if (f)
 		return f;
+
+	sprintf(p, "%s%s", UMR_DB_DIR, COMPRESSED_DB_FILENAME);
+	if (stat(p, &buffer) == 0) {
+		f = umr_database_extract(UMR_DB_DIR, filename, binary);
+		if (f)
+			return f;
+	}
+
 #endif
 
 	// 5. try using CMAKE_SOURCE_DIR/database
 	sprintf(p, "%s/database/%s", UMR_SOURCE_DIR, filename);
-	return fopen(p, mode);
+	f = fopen(p, mode);
+	if (f)
+		return f;
+
+	sprintf(p, "%s/%s", UMR_SOURCE_DIR, COMPRESSED_DB_FILENAME);
+	f = umr_database_extract(UMR_SOURCE_DIR, filename, binary);
+	if (f)
+		return f;
+	
+	// No options worked.
+	return NULL;
 }
-- 
2.51.0

