From 8165b2c2f9e6d58e7a3fdcab3e5682ab61de664b Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Mon, 1 Sep 2025 14:58:16 +0200
Subject: [PATCH] xtest: Send non-matching key codes as syms

Some clients change the keymap of the xtest device when they
want to send syms that are impossible to type with the current
keymap. This can't reach the wayland compositor, instead compare
the syms that they would produce on each keymap and send them
as sym instead.
---
 hw/xwayland/xwayland-xtest.c | 55 ++++++++++++++++++++++++++++++++----
 1 file changed, 50 insertions(+), 5 deletions(-)

diff --git a/hw/xwayland/xwayland-xtest.c b/hw/xwayland/xwayland-xtest.c
index c2aacca66..34551b860 100644
--- a/hw/xwayland/xwayland-xtest.c
+++ b/hw/xwayland/xwayland-xtest.c
@@ -25,12 +25,17 @@
 
 #include <xwayland-config.h>
 
+#include "dixstruct.h"
+#include "xkbsrv.h"
+
 #include <inputstr.h>
 #include <inpututils.h>
 #include <libgen.h>
 #include <unistd.h>
 #include <errno.h>
 
+#include <sys/mman.h>
+
 #include <libei.h>
 
 #ifdef XWL_HAS_EI_PORTAL
@@ -72,7 +77,7 @@ struct xwl_ei_client {
     struct xorg_list link;      /* in clients_for_reuse */
     ClientPtr client;           /* can be NULL if the X11 client is gone */
     char *cmdline;
-    bool accept_pointer, accept_keyboard, accept_abs;
+    bool accept_pointer, accept_keyboard, accept_abs, accept_text;
     struct ei *ei;
     int ei_fd;
 #ifdef XWL_HAS_EI_PORTAL
@@ -82,6 +87,8 @@ struct xwl_ei_client {
     struct ei_seat *ei_seat;
     struct ei_device *ei_pointer;
     struct ei_device *ei_keyboard;
+    XkbDescPtr ei_xkb_map;
+    struct ei_device *ei_text;
     struct xorg_list abs_devices;
     struct xorg_list pending_emulated_events;
 
@@ -177,6 +184,13 @@ add_ei_device(struct xwl_ei_client *xwl_ei_client, struct ei_device *device)
         }
     }
 
+    if (ei_device_has_capability(device, EI_DEVICE_CAP_TEXT) &&
+        xwl_ei_client->ei_text == NULL) {
+        fprintf(stderr, "Xwayland: found ei text device");
+        xwl_ei_client->ei_text = ei_device_ref(device);
+        used = true;
+    }
+
     if (!used)
         ei_device_close(device);
 }
@@ -375,6 +389,7 @@ setup_ei(ClientPtr client)
     xwl_ei_client->accept_pointer = false;
     xwl_ei_client->accept_keyboard = false;
     xwl_ei_client->accept_abs = false;
+    xwl_ei_client->accept_text = false;
     xwl_ei_client->ei = ei;
     xwl_ei_client->ei_fd = -1;
     xwl_ei_client->client = client;
@@ -423,6 +438,8 @@ xwl_ei_start_emulating(struct xwl_ei_client *xwl_ei_client)
     xorg_list_for_each_entry(abs, &xwl_ei_client->abs_devices, link) {
         ei_device_start_emulating(abs->device, sequence);
     }
+    if (xwl_ei_client->ei_text)
+        ei_device_start_emulating(xwl_ei_client->ei_text, sequence);
 }
 
 static void
@@ -533,7 +550,7 @@ xwl_send_abs_event_to_ei(struct xwl_ei_client *xwl_ei_client, int sx, int sy)
 }
 
 static bool
-xwl_send_event_to_ei(struct xwl_ei_client *xwl_ei_client,
+xwl_send_event_to_ei(struct xwl_ei_client *xwl_ei_client, DeviceIntPtr dev,
                      int type, int detail, int flags, const ValuatorMask *mask)
 {
     struct ei *ei = xwl_ei_client->ei;
@@ -592,6 +609,25 @@ xwl_send_event_to_ei(struct xwl_ei_client *xwl_ei_client,
                 return false;
 
             ei_device = xwl_ei_client->ei_keyboard;
+            struct ei_keymap *ei_keymap = ei_device_keyboard_get_keymap(ei_device);
+            if (!xwl_ei_client->ei_xkb_map  && ei_keymap && ei_keymap_get_type(ei_keymap) == EI_KEYMAP_TYPE_XKB) {
+                if (!xwl_ei_client->ei_xkb_map) {
+                    char *keymap = mmap(NULL, ei_keymap_get_size(ei_keymap), PROT_READ, MAP_PRIVATE, ei_keymap_get_fd(ei_keymap), 0);
+                    if (keymap) {
+                       xwl_ei_client->ei_xkb_map = XkbCompileKeymapFromString(dev, keymap, strnlen(keymap, ei_keymap_get_size(ei_keymap)));
+                    }
+                }
+            }
+            if (xwl_ei_client->ei_text && xwl_ei_client->ei_xkb_map) {
+                // FIXME level should probably be accurate
+                int eisym = XkbKeySym(xwl_ei_client->ei_xkb_map , detail, 0);
+                int sym = XkbKeySym(dev->key->xkbInfo->desc, detail, 0);
+                if (sym != eisym) {
+                    ei_device_text_keysym(xwl_ei_client->ei_text, sym, type == KeyPress);
+                    ei_device_frame(xwl_ei_client->ei_text, ei_now(ei));
+                    break;
+                }
+            }
             ei_device_keyboard_key(ei_device, detail - 8, type == KeyPress);
             ei_device_frame(ei_device, ei_now(ei));
             break;
@@ -689,7 +725,7 @@ xwayland_xtest_send_events(DeviceIntPtr dev,
     }
 
     if (accept) {
-        xwl_send_event_to_ei(xwl_ei_client, type, detail, flags, mask);
+        xwl_send_event_to_ei(xwl_ei_client, dev, type, detail, flags, mask);
     }
     else {
         debug_ei("Not yet connected to EIS, queueing events\n");
@@ -707,6 +743,7 @@ xwl_dequeue_emulated_events(struct xwl_ei_client *xwl_ei_client)
     xorg_list_for_each_entry_safe(xwl_emulated_event, next_xwl_emulated_event,
         &xwl_ei_client->pending_emulated_events, link) {
         sent = xwl_send_event_to_ei(xwl_ei_client,
+                                    xwl_emulated_event->dev,
                                     xwl_emulated_event->type,
                                     xwl_emulated_event->detail,
                                     xwl_emulated_event->flags,
@@ -740,6 +777,9 @@ xwl_ei_update_caps(struct xwl_ei_client *xwl_ei_client,
         if (ei_device == abs->device)
             xwl_ei_client->accept_abs = true;
     }
+    if (ei_device == xwl_ei_client->ei_text) {
+        xwl_ei_client->accept_text = true;
+    }
 }
 
 static bool
@@ -750,7 +790,10 @@ xwl_ei_devices_are_ready(struct xwl_ei_client *xwl_ei_client)
         (xwl_ei_client->accept_pointer ||
          !ei_seat_has_capability(xwl_ei_client->ei_seat, EI_DEVICE_CAP_POINTER)) &&
         (xwl_ei_client->accept_abs ||
-         !ei_seat_has_capability(xwl_ei_client->ei_seat, EI_DEVICE_CAP_POINTER_ABSOLUTE)))
+         !ei_seat_has_capability(xwl_ei_client->ei_seat, EI_DEVICE_CAP_POINTER_ABSOLUTE)) &&
+        (xwl_ei_client->accept_text ||
+         !ei_seat_has_capability(xwl_ei_client->ei_seat, EI_DEVICE_CAP_TEXT))
+        )
         return true;
 
     return false;
@@ -803,7 +846,8 @@ xwl_handle_ei_event(int fd, int ready, void *data)
                                               EI_DEVICE_CAP_POINTER_ABSOLUTE,
                                               EI_DEVICE_CAP_BUTTON,
                                               EI_DEVICE_CAP_SCROLL,
-                                              EI_DEVICE_CAP_KEYBOARD, NULL);
+                                              EI_DEVICE_CAP_KEYBOARD,
+                                              EI_DEVICE_CAP_TEXT, NULL);
                 }
                 break;
             case EI_EVENT_SEAT_REMOVED:
@@ -862,6 +906,7 @@ xwl_handle_ei_event(int fd, int ready, void *data)
             case EI_EVENT_DEVICE_RESUMED:
                 debug_ei("Device resumed\n");
                 xwl_ei_update_caps(xwl_ei_client, ei_device);
+
                 /* Server has accepted our device (or resumed them),
                  * we can now start sending events */
                 /* FIXME: Maybe add a timestamp and discard old events? */
-- 
2.50.1

